###
Весь jsx это react обьеты, input, select, textarea соответственно тоже

### Компоненты
Если компонент начинается с маленькой буквы, React принимает его за DOM-тег. Например, <div /> это div-тег из HTML,
а <Welcome /> это уже наш компонент Welcome, который должен быть в области видимости.

### Именование событий в компоненте
on[имя события] для компонентов принижающие props. Handle для компонентов отрабатывающие имя.

### Иммутабельность
Иммутабельность позволяет сохранять предыдущее состояние. Помогает «путешествовать во времени»

### Композиция компонентов
Композиция помогает избавиться от передачи некоторых пропсов на множество уровней вниз.

Способы бороться с передачей на множество уровней вниз.
https://ru.reactjs.org/docs/context.html#before-you-use-context

### Инверсия управления
Cуть паттерна чтобы у общего компонента добавить все необходимые props компонентам и дальше их правильно вложить
друг в друга, похоже на то как можно просто подключать props через redux.

Этого паттерна достаточно для большинства случаев, когда вам необходимо отделить дочерний компонент
от его промежуточных родителей

### Обработка событий
Ещё одно отличие — в React нельзя предотвратить обработчик события по умолчанию, вернув false.
Нужно явно вызвать preventDefault.

### w3c
Организация внедряющая стандарты.

Внутри цикла часто нужно передать дополнительный аргумент в обработчик события. Как правильно ?
https://ru.reactjs.org/docs/handling-events.html#passing-arguments-to-event-handlers

### Философия React
Названия компонентов часто содержаться в макетах, именовать можно как бо БЭМ в контексте приложения.

Статическое приложение. Самый лёгкий способ — создать версию, которая использует модель данных и рендерит
интерфейс, но не предполагает никакой интерактивности. Разделять эти процессы полезно. Написание статического
приложения требует много печатания и совсем немного мышления. С другой стороны, создание интерактивного приложения
подразумевает более глубокий мыслительный процесс и лишь долю рутинной печати. Позже мы разберёмся, почему так
получается.

### Состояние
Состояние часто называют «локальным», «внутренним» или инкапсулированным.
Оно доступно только для самого компонента и скрыто от других.

### Выделение состояния.
Вот здесь, нашел ответ на вопрос как определить состояние.

Задайте себе три вопроса:
Передаются ли они от родителя через пропсы? Если так, тогда эти данные не должны храниться в состоянии компонента.

Остаются ли они неизменными со временем? Если так, тогда их тоже не следует хранить в состоянии.

Можете ли вы вычислить их на основании любых других данных в своём компоненте или пропсов? Если так, тогда это
тоже не состояние.

https://ru.reactjs.org/docs/thinking-in-react.html#step-3-identify-the-minimal-but-complete-representation-of-ui-state
https://ru.reactjs.org/docs/thinking-in-react.html#step-4-identify-where-your-state-should-live

### Доступность контента 
a11y (Accessibility) - в веб-разработке — это обеспечение возможности использования сайтов как можно большим числом
людей, включая тех, чьи способности как-либо ограничены.

Плагин eslint-plugin-jsx-a11y для ESLint выполняет проверку абстрактного синтаксического дерева JSX на
предмет поиска проблем, связанных с доступностью контента.

### Разделение кода
Bundle это процесс выявления всех импортированных файлов и обьеденение их в один собранный файл.
Разделение кода не уменьшит размер bundle, по позволит пользователю при начальной загрузке
не загружать все приложение целиком.

### Контекст
Использование контекста подходит когда одни и те же данные приложения должны быть доступны во многих
компонентах (переводы, темная или светлая тема).
В других случаях советуется использовать композицию, render props и Инверсия управления.

https://ru.reactjs.org/docs/context.html#examples

### Предохранители
Это компоненты React, которые отлавливают ошибки JavaScript в любом месте деревьев их дочерних компонентов,
сохраняют их в журнале ошибок и выводят запасной UI вместо рухнувшего дерева компонентов.

Предохранители отлавливают ошибки при рендеринге, в методах жизненного цикла и конструкторах деревьев компонентов,
расположенных под ними.

Предохранители не поймают ошибки в: обработчиках событий, асинхронном коде
(например колбэках из setTimeout или requestAnimationFrame), серверном рендеринге (Server-side rendering)
самом предохранителе (а не в его дочерних компонентах).

Чтобы отловить ошибку в обработчике событий, пользуйтесь обычной JavaScript-конструкцией try / catch:

Классовый компонент является предохранителем, если он включает хотя бы один из следующих методов
жизненного цикла: static getDerivedStateFromError() или componentDidCatch().
Используйте static getDerivedStateFromError() при рендеринге запасного UI в случае отлова ошибки.
Используйте componentDidCatch() при написании кода для журналирования информации об отловленной ошибке.

https://ru.reactjs.org/docs/error-boundaries.html#live-demo

### Перенаправление рефов
Полезно когда компоненту получить ref и передать его дочернему. Реализовать можно с помощью компонента
`React.forwardRef`. Так же можно сделать через HOC, при этом нужно не забыть добавить имя 
компоненту (displayName)

### HOC
Самый простой пример это функция connect, witRouter. HOC желательно присваивать displayName.
Он также может принимать функцию с конфигурацией.

### JSX в деталях
null, undefined, false, true игнорируются, ноль отображается.


### Оптимизация производительности
Понял что одна из причин почему не стоит мутировать состояние в реакт это из за
компорента переписовки он сравнивает объекты по ссылке при мутировании ссылка не поменяется
и могут возникнуть проблемы например с рендером.

React Profiler - инструмент разработчика анализа производительности в режиме разработки.
Виртуализация длинных списков, react-window и react-virtualized — это популярные библиотеки
для оконного доступа. Использование React.PureComponent или React.memo

```js
function MyComponent(props) {
  /* render using props */
}
function areEqual(prevProps, nextProps) {
  /*
  return true if passing nextProps to render would return
  the same result as passing prevProps to render,
  otherwise return false
  */
}
export default React.memo(MyComponent, areEqual);
```

подойдет для собеса
https://ru.reactjs.org/docs/optimizing-performance.html#examples
а это в codestyle https://immerjs.github.io/immer/example-setstate

### API для работы с Profiler
https://ru.reactjs.org/docs/profiler.html#onrender-callback

https://ru.reactjs.org/docs/refs-and-the-dom.html